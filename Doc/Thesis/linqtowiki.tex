\chapter{The LinqToWiki library}

The LinqToWiki library consists of one Visual Studio solution, that contains the following projects:

\begin{itemize}
\item LinqToWiki.Core
\item LinqToWiki.Codegen
\item LinqToWiki.Codegen.App
\item LinqToWiki.ManuallyGenerated
\item LinqToWiki.Samples
\end{itemize}

The LinqToWiki.Core project contains the core of the library:
types that access the API, convert to and from the representation of data in the API,
represent parameters of various types of queries, represent query results
or those that process LINQ expression trees.
This project can be used together with code generated using LinqToWiki.Codegen,
or with manually written code.

The LinqToWiki.Codegen project handles generating code based on information from the \texttt{paraminfo} module.
It contains types that represent the results of that module, process them, generate C\# code and compile this code using Roslyn.
This project also contains helper types for easier creating of Roslyn syntax trees.

The LinqToWiki.Codegen.App compiles down to a simple console application called linqtowiki-codegen,
that uses the functionality from the LinqToWiki.\allowbreak{}Codegen project.

The LinqToWiki.ManuallyGenerated project is a sample of how one could write code to access a wiki using LiqToWiki without using LinqToWiki.Codegen to generate the code.

Finally, the LinqToWiki.Samples project contains samples showing how to use various API modules using LinqToWiki.
It uses code generated by LinqToWiki.\allowbreak{}Codegen.\allowbreak{}App.

\medskip

The intended usage of LinqToWiki is this:
First run the linqtowiki-codegen application to generate a DLL library tailored for a certain wiki.
Then use the generated library together with LinqToWiki.Core in your C\# (or VB.NET) application to access that wiki.

Other options are possible, though.
For example, the linqtowiki-codegen application can be used to generate the code as a set of files containing C\# source code.
Those files can then be modified and manually compiled.

\section{The LinqToWiki.Core project}

The LinqToWiki.Core project contains shared code that can be used when querying any MediaWiki wiki.
It can be used together with code generated through LinqToWiki\allowbreak{}.Codegen,
but it can also be used without it.

In fact, LinqToWiki.\allowbreak{}Codegen internally uses LinqToWiki.Core to access the \texttt{paraminfo} module
using manually written code.

\subsection{\lstinline{QueryTypeProperties}}

The \lstinline{QueryTypeProperties} class holds basic information about a “query type”,
which corresponds to an API module.
Those information include the prefix this module uses in its parameters,
what type of module it is or mapping of its result properties to values accepted by the \texttt{prop} parameter.
It is also able to parse XML elements this module returns.

\subsection{\lstinline{WikiQuery}}

Probably the most often used and certainly the most interesting queries are those using \texttt{list} query modules.
Such queries are represented by a group of types whose names start with \lstinline{WikiQuery}.

Specifically, there are four such types:
\lstinline{WikiQuery}, \lstinline{WikiQuerySortable}, \lstBreak{Wiki\-Query\-Generator} and \lstinline{WikiQuerySortableGenerator}.
If a module supports sorting, it is represented by a type with \lstinline{Sortable} in its name
and if it supports being used as a generator for \texttt{prop} queries, it is represented by a type with \lstinline{Generator} in its name.

For a state diagram of transitions between the \lstinline{WikiQuery} types and other related types, see Figure~\ref{WikiQuery types}.

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[>=angle 90]
\path (0,9) node(WQS) {\lstinline{WQSortable}};
\path (5,9) node(WQ) {\lstinline{WQ}};

\path (5,6) node(WQR) {\lstinline{WQResult}};
\path (9,7.5) node(List) {\lstinline{List}};
\path (9,4.5) node(IE) {\lstinline{IEnumerable}};

\path (0,3) node(WQSG) {\lstinline{WQSortableGenerator}};
\path (5,3) node(WQG) {\lstinline{WQGenerator}};

\path (0,0) node(PS) {\lstinline{PageSource}};
\path (5,0) node(WQPR) {\lstinline{WQPageResult}};
\path (9,1.5) node(PList) {\lstinline{List}};
\path (9,-1.5) node(PIE) {\lstinline{IEnumerable}};

\draw[->] (WQS) edge [out=188,in=172,looseness=5,auto] node {\lstinline{Where}} (WQS);
\draw[->] (WQS) edge node[above] {\lstinline{OrderBy}} (WQ);
\draw[->] (WQS) edge node[below left] {\lstinline{Select}} (WQR);

\draw[->] (WQ) edge [out=-20,in=20,looseness=8,right] node {\lstinline{Where}} (WQ);
\draw[->] (WQ) edge node[right] {\lstinline{Select}} (WQR);

\draw[->] (WQR) edge node[below right] {\lstinline{ToList}} (List);
\draw[->] (WQR) edge node[above right] {\lstinline{ToEnumerable}} (IE);

\draw[->] (WQSG) edge [out=185,in=175,looseness=5,auto] node {\lstinline{Where}} (WQSG);
\draw[->] (WQSG) edge node[auto] {\lstinline{OrderBy}} (WQG);
\draw[->] (WQSG) edge node[above left] {\lstinline{Select}} (WQR);

\draw[->] (WQG) edge [out=-8,in=8,looseness=5,right] node {\lstinline{Where}} (WQG);
\draw[->] (WQG) edge node[right] {\lstinline{Select}} (WQR);

\draw[->] (WQSG) edge node[auto] {\lstinline{Pages}} (PS);
\draw[->] (WQG) edge node[auto] {\lstinline{Pages}} (PS);

\draw[->] (PS) edge node[auto] {\lstinline{Select}} (WQPR);
\draw[->] (WQPR) edge node[below right] {\lstinline{ToList}} (PList);
\draw[->] (WQPR) edge node[above right] {\lstinline{ToEnumerable}} (PIE);

\end{tikzpicture}
\end{center}

\caption{State diagram of \lstinline{WikiQuery}-related types \\ (\lstinline{WikiQuery} is shortened to \lstinline{WQ} to save space)}
\label{WikiQuery types}

\end{figure}

\medskip
\pagebreak[0]

% try explaining in more detail

All of the \lstinline{WikiQuery}-related types are generic
and their type parameters are used to decide what properties can be used in each operation.
For example, the type parameter \lstinline{TOrderBy} of \lstinline{WikiQuerySortable}
decides what properties can be used in the parameter of the \lstinline{OrderBy} method.

The way this is achieved is that \lstinline{TOrderBy} is a type that contains the properties that can be
used for sorting in the module \lstinline{WikiQuerySortable} represents
and the \lstinline{OrderBy} method accepts lambda expressions whose parameter is of this type.

For example, if some module supported sorting by \lstinline{PageId} and \lstinline{Title},
then \lstinline{TOrderBy} would be a type that contains two properties with those names.
Because of this, a query like \lstinline{query.OrderBy(x => x.Title)} would compile and execute fine,
but \lstinline{query.Orderby(x => x.Name)} would fail to compile.

Because of the way lambda expressions work, queries like \lstBreak{query.OrderBy(x => x.Title.Substring(1))} or \lstBreak{query.OrderBy(x => random.Next())} would compile fine.
But because there is no way to efficiently execute such queries using the MediaWiki API,
they will fail with an exception at runtime.

\medskip



% WikiQuery
% PageSources and types related to prop queries
% ExpressionParser
% QueryParameters
% QueryProcessor, its helpers

\subsection{\lstinline{Downloader}}

% TODO: reword
Probably the most basic type in this project is \lstinline{Downloader}.
It takes care of forming the query string, executing the request and
returning the result as an \lstinline{XDocument}.

\lstinline{XDocument} is part of LINQ to XML, a part of .Net framework for manipulating XML documents.

\lstinline{Downloader} always uses POST and formats its requests as \path{application/x-www-form-urlencoded}.
This means that all modules work, including those that require POST.
On the other hand, uploads of files don't work, because they require \path{multipart/form-data}.

The decision to use \path{application/x-www-form-urlencoded} follows from the fact that
\path{multipart/form-data} is very inefficient when sending multiple parameters with short values,
which is common when making requests to the API.

% TODO: maybe some conclusion?

\section{The LinqToWiki.Codegen project}

\section{The linqtowiki-codegen application}

\section{Samples of queries}