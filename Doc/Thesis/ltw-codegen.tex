\section{The LinqToWiki.Codegen project}
\label{ltwc}

The LinqToWiki.Codegen project contains code that retrieves information about API modules in some wiki,
then uses that information to generate C\# code to access those modules using Roslyn
and finally compiles the code into a library.

\medskip

Roslyn was chosen, because it is superior when compared with common approaches for code generation in .Net,
namely Reflection.Emit and CodeDOM.

Reflection.Emit \cite{reflection-emit} is a set of types that allow code generation of code at runtime.
The generated code can then be directly executed or saved as an assembly (.dll or .exe) to disk.
The distinguishing feature is that it uses the low-level Common Intermediate Language (CIL),
which means writing any code beyond the simplest methods can be very tedious and error-prone.

CodeDOM \cite{codedom} can be used to generate code and compile it to an assembly.
It uses language-independent model, which can be converted to various .Net languages,
including C\# and VB.NET.
This model is also the biggest disadvantage of CodeDOM, because it means it doesn't support all features of C\#.
For example, even such basic feature as writing a \lstinline{static} class is impossible in the CodeDOM model
without using “hacks”.

Detailed description of Roslyn is in Section~\ref{roslyn}.

\medskip

At this point, we have a library (LinqToWiki.Core) that can be used to access the MediaWiki API the way we want
from the final generated library.
We can also use the same library to get the information we need about the modules of the API from the \texttt{paraminfo} module.
And we have decided we want to use Roslyn to generate the final library.
What remains is to decide what code to generate, how exactly to map the modules, their parameters
and their results into the model of LinqToWiki.Core.

% think about moving this before LTW.Core

There are some decisions that were already made in LinqToWiki.Core
(the \texttt{sort} and \texttt{dir} parameters should map to \lstinline{OrderBy()};
the \texttt{prop} parameter maps to \lstinline{Select()}),
but several other decisions still remain:\footnote{
Obviously, both libraries were written alongside each other, to work well together, not one after the other.
But we think it's better to describe them this way, separately.}

\begin{itemize}
\item How should the remaining parameters be mapped?
Should they all go into \lstinline{Where()} or somewhere else? Where?
\item How should the modules that don't return lists be mapped?
LINQ methods are not suitable for them, because they are meant to work with collections.
\item How to name the generated types and members?
Specifically, how to represent names that can't be used (like those containing special characters)
and names that are undesirable (those that conflict with a C\# keyword).
Also, should the generated members follow .Net naming conventions?
\end{itemize}

Our answers to these questions are in the following couple of sections.

\subsection{Naming of generated types and members}

Let's start with the last question: Should the generated members follow .Net naming conventions?
The .Net naming guidelines \cite{guidelines-for-names},
that are widely followed by various .Net libraries and the .Net framework itself,
state that names of types and public members should use PascalCase,
that is, each word of an identifier should start with a capital letter
and the identifier should not contain any delimiters (such as underscores).

We would prefer to follow these naming conventions, but unfortunately it is not possible.
That is because the names of modules, parameters, result properties and almost all enumerated types in the API
use names that are all lowercase, without delimiters between words.
That means there is no way to figure out which letters in an identifier should be capitalized
(apart from the first one).

As one of the more extreme examples,
one of the possible values of the \texttt{rights} parameter
of the \texttt{allusers} module on the English Wikipedia is \texttt{collection\-save\-as\-community\-page}.
A human can see that the proper name for that value using PascalCase would be \lstinline{CollectionSaveAsCommunityPage},
but a computer cannot.
(Actually, it is possible that the words could be reliably separated using natural language processing,
but doing that is outside the scope of this work.)