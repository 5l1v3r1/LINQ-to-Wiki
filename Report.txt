# Report použití nástrojù pro verifikaci kódu

## Popis projektu

Jako projekt jsem zvolil mou bakaláøskou práci, jedná se o projekt LinqToWiki, což je knihovna pro pøístup k wiki stránkám, keteré pužívají MediaWiki (napøíklad Wikipedie) pomocí jejich API.
Knihovna je napsaná v C# a je dostupná na https://github.com/svick/LINQ-to-Wiki.

Knihovna se skládá ze tøí èástí: LinqToWiki.Codegen, LinqToWiki.Generated a LinqToWiki.Core.
LinqToWiki.Codegen ète popis MediaWiki API a na jeho základì vygeneruje LinqToWiki.Generated.
LinqToWiki.Generated je kód generovaný pomocí LinqToWiki.Codegen.
LinqToWiki.Core tvoøí základ knihovny a používá se spolu s LinqToWiki.Generated k samotnému vykonávání dotazù vùèi MediaWiki API.

Vzhledem ke zmìnám v MediaWiki, LinqToWiki.Codegen momentálnì nefunguje, ale knihvana je použitelná s døíve vygenrovanou verzí LinqToWiki.Generated.
LinqToWiki.Generated by bylo tìžké analyzovat, protože jeho zdrojové soubory existují jenom doèasnì pøi bìhu LinqToWiki.Codegen.

Pro vyzkouèení knihovny navíc ještì existuje LinqToWiki.Samples.

Pro analýzu jsem tedy použil jenom LinqToWiki.Core, verze zdrojového kódu, ze které jsem vycházel je ve vìtvi program-analysis: https://github.com/svick/LINQ-to-Wiki/tree/program-analysis.

## Code Contracts

Code Contracts jsem vyzkoušel tak, že jsem zaèal s nejnižší úrovní varování, všechna varování opravil, zvýšil úroveò varování a tak dále.

Zmìny v kódu vyžadované pro odstranìní CC varování byly pøevážnì nìkolika druhù:

* Specifikovat pomocí Requires(), že parametry metod nesmìjí být null.

* Specifikivat pomocí Assume(), že knihovní funkce, která mùže vracet null ji v tomto pøípadì nevrací.

  Tato situace nastala napøíklad tehdy, když jsem použil výsledek indexování do Dictionary.
  Pokus s specifikaci, že hodnoty v tomto Dictionary nikdy nebudou null pomocí Contract.Invariant(Contract.ForAll(m_pages, kvp => kvp.Value != null)) nepomohl.

  Dalším pøíkladem jsou Linq to XML funkce jako XElement.Element(), která vrací null, v pøípadì že syn s daným jménem neexistuje.

* Specifikovat pomocí Ensures(), že metoda nevrací null.

* Specifikovat pomocí Assume() nebo Requires(), že kolekce má urèitý poèet hodnot.

  To, znamená, že napøíklad pøed voláním Single() je potøeba specifikovat, že kolekce má právì jeden prvek.

Podle mého názoru jsou na vyšších úrovních varování CC témìø nepoužitelné, protože vyžadují velké množství Assume(), které nejsou pøiliš užiteèné.
Tedy alespoò za pøedpokladu, že vyhození NullReferenceException v pøípadì, že API vrací XML v neoèekávaném formátu, nebo v pøípadì, že se uživatel pokusí použít knihovnu neoèekávaným zpùsobem,
je pøijatelné.

Na nízkých úrovních varování CC pøedevším nutí specifikvat ne-null Requires() u veøejných metod, což je užiteèné.

Použití CC (v módu kdy nebìží na pozadí) kompilaci znaènì zpomalovalo.

Výsledný kód je ve vìtvi code-contracts: https://github.com/svick/LINQ-to-Wiki/tree/code-contracts.

## Pex / IntelliTest

Pex jsem použil pomocí funkce IntelliTest ve Visual Studiu 2015.

Moje zkoušení Pexu probíhalo tak, že jsem Pex nechal vždy vygenerovat testy pro nìjakou tøídu.
Nejprve jsem zkontroloval varování: pokud se nìkteré zdálo opravitelné, tak jsem se jej pokusil opravit.
Následnì jsem zkontroloval vygenerované testy: pokud nìkterý neuspìl, z dùvodu vyhozené neoèekávané výjimky,
tak jsem jej buï opravil vyhozením oèekávané výjimky, nebo jeho ignorováním.


Co se opravování varování týèe, vìtšinou se jednalo o vytvoøení factory metody, pomocí nichž by Pex mohl vytvoøit instance objektu.
Problém nastal se dvìma typy hojnì použivanými v této knihovnì: Expression a XElement.

U Expression se podaøilo vytvoøit factory pro nìkteré jdnodušší podtøídy (napø. ConstantExpression nebo UnaryExpression),
ale problém nastal u podtøíd, které používají reflection objekty (napø. MemberExpression používá MemberInfo).
Pokusil jsem se reflection objekty vyvtoøit pomocí jejich oèíslování (napø. Type: AppDomain.CurrentDomain.GetAssemblies()[assemblyIndex].GetTypes()[typeIndex]),
ale ani to neuspìlo.

U XElementu byl problém se jménem: Pex mìl problém vytvoøit string, který by byl pøijatelným jménem XML elementu.


Co se neúspìšných testù týká, jednalo se pøedevším o výjimky zpùsobené null.
Pokud byl problém null parameter, keterý zpùsobil NullReferenceException nebo ArgumentNullException u nìjaké volané metody,
tak jsem jej opravil pøidáním prerekvizity, tzn. vyhozením ArgumentNullException na zaèátku metody.

Pokud byl problém hloubìjí (typicky null prvek v kolekci), tak jsem se rozhodl výjimku ignorovat.


Pøišlo mi, že kromì vyhozených výjimek vygenerované testy velmi èasto netestovaly žádné zajímavé vlastnosti (jako tøeba hodnoty vráceného objektu)
a teké nemìl pøíliš zajímavé hodnoty parametrù.
Velká èást testù spoèívala jenom v testování reakcí na null (a èasto opakovanì).

Vygenerování testù u nìkterých metod trvalo pomìrnì dlouhou dobu,
nejvýraznìjší to asi bylo u metody QueryRepresentation.ToQueryStringDynamic,
což je velice jednoduchá metoda, která používá dynamic (takže její IL kód tak jednoduchý není):
u ní Pex pracoval dlouho a nebyl schopný vygenerovat žádný test.


Vzhledem k tomu, jaké množství práce použití Pexu vyžaduje (pøedevším ruèní psaní factory metod)
a vzhledem k tomu, že stejnì nakonce pøevážne testuje null, tak mi nepøijde prakticky pøíliš užiteèný.


Výsledný kód je ve vìtvi pex: https://github.com/svick/LINQ-to-Wiki/tree/pex.
